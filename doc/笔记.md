**<center><span style="font-size:62px;">OI笔记</span></center>**

[TOC]

<div STYLE="page-break-after: always;"></div>
# 数据结构

## 可并堆

>  可并堆是一类特殊的堆结果，它们在普通堆的操作外，还支持快速合并两个堆的操作

<font size=5>**左偏树**</font>

- 左偏树是可并堆的一种，因其树的结构偏向左子树命名

**操作实现**

​	对每一个节点，都维护了这个节点与子树中最近叶节点距离$Dis$

- 合并函数$Merge$

  1. 向下迭代：将优先级较小的节点与优先级较大的右子树合并
  2. 向上回溯：通过交换左右儿子的方式，使左儿子$Dis$大于右儿子

  - 若要插入节点，将插入节点看做只有一个节点的左偏树直接合并

- 删除优先级最大节点（根节点）

  1. 将根节点与左右子树分离
  2. 合并原来的左右子树

**优缺点**

- 代码难度小
- 时间复杂度低
- 支持持久化+$Lazy$标记
- 常数巨大

<font size=5>**斐波那契堆&配对堆**</font>

- 斐波那契堆是一种实现困难、均摊复杂度优越的堆数据结构
- 斐波那契堆是一种双向链表维护的多叉森林
- 配对堆是一种实现简单、均摊复杂度优越的堆数据结构
- 配对堆是一种邻接链表维护的多叉树，是一种简化的斐波那契堆

<font size=4>**斐波那契堆**</font>

**堆指针内容**

- 堆顶$Root$
- 节点总数$Num$

**节点内容**

- 节点优先级$Key$
- 父亲节点$Father$
- 最近儿子节点$Son$
- 儿子总数$Dis$
- 左兄弟节点$Left$
- 右兄弟节点$Right$
- 删除标记$Mark$

**操作实现**

- 子树合并：将$Dis$相同的树合并，合并时$Key$较小根进行$Mark\gets  False$
- 级联切断：向上搜索时将所有$Mark= True$的祖先（包括自己）设为根，当遇到$Mark= False$的祖先时进行$Mark\gets  True$，然后退出
- 合并操作：将两个堆的$Root$用$Left/Right$连接，再更新$Root$
- 插入操作：将插入节点看做新堆，然后合并
- 取最值操作：直接返回$Root$
- 删除操作：将$Root$的所有儿子设为根，删除$Root$，子树合并，更新$Root$
- 改小操作：先修改，当不满足堆性质时将操作节点设为根，再对原$Father$进行级联切断

<font size=4>**配对堆**</font>

**配对堆与斐波那契堆的区别与联系**

- 联系：将每个斐波那契堆的$Root$设为其他所有兄弟的父亲时即为配对堆
- 区别：配对堆由于缩减，修改速度变为$\varTheta \left( \log\ n \right) $（斐波那契堆$\varTheta \left( 1 \right)$ ）

**堆指针内容**

- 树根$Root$
- 节点总数$Num$

**节点内容**

- 节点优先级$Key$
- 父亲节点$Father$
- 最近儿子节点$Son$
- 兄弟节点$Brother$

**操作实现**

- 合并操作：将$Root.Key$较小的堆设为$Root.Key$较大的堆的$Root$的儿子
- 插入操作：将插入节点看做新堆，然后合并
- 取最值操作：直接返回$Root$
- 删除操作：删除$Root$，再两两合并$Root$原来的所有子树，更新$Root$
- 修改操作：将操作节点与$Father$断联，修改$Key$后合并

## $Splay$

- $Splay$是一种无需外加数据，均摊复杂度优越的平衡二叉树

- $Splay$的操作方式灵活多样，且是其他许多数据结构的基础

**基本操作函数实现**

- 双旋：当父亲和自己为对应父亲的同一侧儿子时，先旋转父亲，再旋转自己；否则旋转两次自己
- $Splay$：优先用双旋将操作节点移向目标节点，当操作节点是目标节点的孙子时再进行一次单旋即可
- 插入／删除／查询／区间翻转：先将加入数据的前缀和后继用$Splay$设为根和根的右儿子，再进行插入／删除／查询／打$Lazy$标记

**优缺点**

- 实现方便快捷
- 时间复杂度与常数比较优秀
- 可套用不同算法的模板
- 不支持持久化（原因：时间复杂度为均摊复杂度）

## $Treap$

- $Treap$是一种将堆和搜索二叉树结合起来的随机化数据结构

- $Treap$分普通$Treap$与无旋$Treap$两种，实现方法大同小异

<font size=5>**普通$Treap$**</font>

**操作实现关键**

- 在每一个节点上维护两个数：键值$Data$和关键字$Key$

- 按照正常的搜索二叉树维护$Data$，然后利用单旋操作使$Key$形成一个堆

**普通$Treap$优缺点**

- 代码简单，实现快速
- 时间复杂度低：$\Theta(log(n))$
- 调试困难（含随机化）
- 无法可持久化

<font size=5>**无旋$Treap$**</font>

**无旋$Treap$与普通$Treap$的区别：**

- 无需旋转操作（因此不需要维护一个节点的$Father$）
- 特殊函数Merge，用于合并两个$Treap$
- 特殊函数$Split$，用于将某子树与原$Treap$分离
- 是一种可持久化的数据结构

**合并函数$Merge$与分裂函数$Split$实现**

- 用维护左偏树的方法实现$Merge$
- 通过递归维护已有的$Ans=\left(Treap,Treap\right)$来实现$Split$

**普通操作实现**

- 插入：先$Split$，按插入值将$Treap$分开，再将这三棵$Treap$用$Merge$合并
- 删除：先用$Split$分离删除节点，再用$Merge$恢复原$Treap$（和插入相反）
- 查询：**不能按搜索二叉树查询！**将原$Treap$按Split分离，再重新合并
- 前驱、后继：同查询操作
- 区间翻转：将边界用$Split$分离，然后打$Lazy$标记

**优缺点**
- 代码简单
- 有和普通$Treap$差不多的速度
- 可以改造为支持持久化的数据结构
- 调试较困难（也是因为含随机因素）

## 主席树（可持久化线段树）

- 主席树是线段树的一种变种，支持可持久化
- 主席树利用了线段树左右儿子互不影响的特点，达到优化效果

**主席树修改方法**

1. 一路向上回溯，对每一个修改过的节点，都建一个新点
2. 让$New\ Note$与$New\ Son$、$Son’s\ Bro$相连
3. 回溯结束后，记录此次操作对应的根节点

**主席树优缺点**

- 拥有和线段树差不多的速度
- 支持持久化（常见可持久化容器）
- 操作实现方式麻烦

## 跳表&块状数组

- 跳表与块状数组都是普通单向的不同优化
- 二者的前置知识都为链表

### 块状数组

- 块状数组是存储了数组的链表
- 综合了数组的高效查询和链表的高效插入删除

**节点存储内容**

- 存储的数据（数组）$Data$
- 所存数组的长度$Size$
- 下一个节点$Next$

**操作函数实现**

- 分裂节点：创造两个新的节点，存储操作节点分裂后的两端数据
- 连接节点：创造一个新的节点，存储操作节点合并后的数据
- 插入数据：先在指定位置分裂，插入后再维护
- 删除数据：先将指定数据分裂出来，再直接删除
- 询问操作：直接顺着链表结构向下找，直到找到为止

### 跳表

- 跳表通过增加链表指针的方式加快在链表上移动的速度
- 事实上是一种随机化+空间换时间的优化

**节点存储内容**

- 节点数据$Data$
- 同层链表下一节点$Next$
- $Next$数组长度$Len$

**操作函数实现**

- 加入节点：首先初始化$Len\gets  1$，然后以$50\%:50\%$的概率$Len++$或退出循环，然后按照$Len$的大小维护$Next$链表上前一个节点与本节点的$Next$，每层$Next$都指向有同层指针的节点，最后插入节点

- 删除节点： 首先维护$Next$链表上前一个节点的$Next$，然后删除节点

- 查询操作：优先往较高层的$Next$走，直到到达目标节点为止

## $LCT$动态树

**前置知识**

- $Splay$
- 树链剖分

**节点内容**

- 节点值$Key$
- $Splay$父亲节点：$Father$
- $Splay$左儿子：$Left$
- $Splay$右儿子：$Right$

**$Splay$结构的意义**

- $Splay$维护数据：原树的一条重链
- 排序优先级：节点在原树深度$Height$（无需存储）
- $x.Father.Right\ne x$的节点：所在$Splay$的$Root$
- $Splay$的最小节点：原树重链的深度最小点
- $Splay$的最大节点：原树重链的深度最大点

**操作函数**
- 访问$Access$：将原树树根到节点$x$的路径设置为重链
  
  > 1. 将$x$设为所在$Splay$的根节点
  > 2. 将$x$的重儿子设为轻儿子（切断原重链）：$x.Right\gets  NULL$
  > 3. 连接两个$Splay$：$x.Father.Right\gets  x$
  > 4. 重复步骤1与步骤3，直到$x.Father=NULL$为止
  
- 换根$MakeRoot$：将原树转换为以节点$x$为树根的有根树
  > 1. 用$Access$将树根到$x$的路径设置为重链
  > 2. 将$x$设为此时所在$Splay$的根节点
  > 3. 通过$Lazy$标记翻转整个$Splay$
  
- 找根$FindRoot$：找到节点$x$所在原树的树根
  > 1. 用$Access$将树根到$x$的路径设置为重链
  > 2. 返回此时$x$所在$Splay$中的深度最小节点
  
- 分离树链$Split$：将原树中节点$u$到$v$的路径分离出来
  > 1. 将链的一端$u$用$MakeRoot$设为树根
  > 2. 用$Access$将$u$到$v$的路径设置为重链
  > 3. 返回此时$v$与$v$在$Splay$上的左子树即可
  
- 连接原树$Link$：将节点$u$与节点$v$所在的原树通过边$(u, v)$连接起来
  > 1. 将边的一端$u$用$MakeRoot$设为树根
  > 2. 用轻边连接节点$u$与节点$v$：$u.Father\gets  v$
  
- 切断原树$Cut$：切断原树上的边$(u,v)$
  > 1. 先将边$(u,v)$用$Split$变为$Splay$上的边
  > 2. 检查$u$是否有右子树或$u$是否为$v$的左儿子
  > 3. 如果$u$有右子树或$u$不为$v$的左儿子，则边$(u,v)$不存在，直接退出
  > 4. 否则直接切断$u$与$v$的父子关系即可
  
- 改变点值$Modify$
  > 1. 将操作节点$x$用$MakeRoot$设为树根，避免还要向上更新信息
  > 2. 直接修改$x$的点值

<div STYLE="page-break-after: always;"></div>
# 数论算法

## $Miller\ Rabin$素性检验

**理论基础**

- 费马小定理：$\forall p\in \mathbb{P}\;\forall a\in \mathbb{N}^{\ast}\qquad a^{p-1}\equiv 1\left( mod\ p \right) $
- 引理：$\forall p\in \mathbb{P}\;\forall a^2\equiv 1\left( mod\ p \right) \qquad a\equiv \pm 1\left( mod\ p \right) $

**实现方法**

1. 输入被测试数$p$，并检查$p$是否为$2$
2. 求出$p=2^mk+1\mspace{27mu}k=\max \left\{ n\in \mathbb{N}\ and\ 2^n\mid \left( p-1 \right) \right\} $
3. 选择测试数$a$（尽量为素数）
4. 扫描是否有$a^k\equiv 1\left( mod\ p \right) $或$a^{2^xk}\equiv -1\left( mod\ p \right) \quad x\in \mathbb{N}\ and\ x\in \left[ 0,k-1 \right] $成立
5. 如果成立，则$p$可能为素数，否则$p$一定是合数
6. 重复步骤3~5，直到次数足够为止

**时空复杂度**

- 时间复杂度$\varTheta \left( k\log \left( p \right) \right) $，其中$k$为测试组数
- 空间复杂度$\varTheta \left( 1 \right) $

## $Pollard’s\ rho$大数分解算法

**理论基础**

- 最大公约数定义：$gcd\left( a,b \right) \mid b$
- 生日悖论：对离散型随机变量$x_1,x_2\in \left[ 0,n \right)$，$(x_1-x_2)$出现重复的期望步数为$\varTheta \left( \sqrt{n} \right) $

**算法实现**

1. 构建伪随机变量$x,y$（一般使用公式$f(x)=x^2+c$）
2. 如果$x,y$已经重复，直接退出程序
3. 如果$gcd\left( x-y,n \right) \ne 1\ or\ n$，则找到$n$的一个因子$gcd\left( x-y,n \right) $

**时空复杂度**

- 时间复杂度$O \left( \alpha \left( n \right) \cdot \sqrt{p} \right) $，其中$p$为$n$的最小因子
- 空间复杂度$\varTheta (1)$

## 多项式变换

### $FFT$离散傅里叶变换／$IFFT$离散傅里叶逆变换

**理论基础**
$$
\left( \begin{matrix}
	1&		1&		1&		\cdots&		1\\
	1&		\omega _{n}^{1}&		\omega _{n}^{2}&		\cdots&		\omega _{n}^{n-1}\\
	1&		\omega _{n}^{2}&		\omega _{n}^{4}&		\cdots&		\omega _{n}^{2n-2}\\
	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
	1&		\omega _{n}^{n-1}&		\omega _{n}^{2n-2}&		\cdots&		\omega _{n}^{\left( n-1 \right) \left( n-1 \right)}\\
\end{matrix} \right) \left( \begin{array}{c}
	a_0\\
	a_1\\
	a_2\\
	\vdots\\
	a_{n-1}\\
\end{array} \right) =\left( \begin{matrix}
	1&		0&		1&		\cdots&		0\\
	1&		0&		\omega _{n/2}^{1}&		\cdots&		0\\
	1&		0&		\omega _{n/2}^{2}&		\cdots&		0\\
	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
	1&		0&		\omega _{n/2}^{n-1}&		\cdots&		0\\
\end{matrix} \right) \left( \begin{array}{c}
	a_0\\
	a_1\\
	a_2\\
	\vdots\\
	a_{n-1}\\
\end{array} \right) +\omega _{n}^{1}\left( \begin{matrix}
	0&		1&		0&		\cdots&		1\\
	0&		\omega _{n/2}^{1}&		0&		\cdots&		\omega _{n/2}^{n/2-1}\\
	0&		\omega _{n/2}^{2}&		0&		\cdots&		\omega _{n/2}^{n-2}\\
	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
	0&		\omega _{n/2}^{n-1}&		0&		\cdots&		\omega _{n/2}^{\left( n-1 \right) \left( n/2-1 \right)}\\
\end{matrix} \right) \left( \begin{array}{c}
	a_0\\
	a_1\\
	a_2\\
	\vdots\\
	a_{n-1}\\
\end{array} \right) \qquad n=2^k
$$
$$
\left( \begin{matrix}
	1&		1&		1&		\cdots&		1\\
	1&		\omega _{n}^{1}&		\omega _{n}^{2}&		\cdots&		\omega _{n}^{n-1}\\
	1&		\omega _{n}^{2}&		\omega _{n}^{4}&		\cdots&		\omega _{n}^{2n-2}\\
	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
	1&		\omega _{n}^{n-1}&		\omega _{n}^{2n-2}&		\cdots&		\omega _{n}^{\left( n-1 \right) \left( n-1 \right)}\\
\end{matrix} \right) ^{-1}=\frac{1}{n}\left( \begin{matrix}
	1&		1&		1&		\cdots&		1\\
	1&		\omega _{n}^{-1}&		\omega _{n}^{-2}&		\cdots&		\omega _{n}^{-\left( n-1 \right)}\\
	1&		\omega _{n}^{-2}&		\omega _{n}^{-4}&		\cdots&		\omega _{n}^{-\left( 2n-2 \right)}\\
	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
	1&		\omega _{n}^{-\left( n-1 \right)}&		\omega _{n}^{-\left( 2n-2 \right)}&		\cdots&		\omega _{n}^{-\left( n-1 \right) \left( n-1 \right)}\\
\end{matrix} \right)
$$

**实现方法**

- $FFT\left( L,R \right) =\left( \begin{matrix}
  	1&		1&		1&		\cdots&		1\\
    	1&		\omega _{R-L}^{1}&		\omega _{R-L}^{2}&		\cdots&		\omega _{R-L}^{R-L-1}\\
    	1&		\omega _{R-L}^{2}&		\omega _{R-L}^{4}&		\cdots&		\omega _{R-L}^{2R-2L-2}\\
    	\vdots&		\vdots&		\vdots&		\ddots&		\vdots\\
    	1&		\omega _{R-L}^{n-1}&		\omega _{R-L}^{2n-2}&		\cdots&		\omega _{R-L}^{\left( R-L-1 \right) \left( R-L-1 \right)}\\
  \end{matrix} \right) \left( \begin{array}{c}
  	a_L\\
  	a_{L+1}\\
  	a_{L+2}\\
  	\vdots\\
  	a_{R-1}\\
  \end{array} \right) $
- 则可知$FFT\left( L,R \right) =FFT^{\left[ 0 \right]}\left( L,\frac{L+R}{2} \right) +\omega _{R-L}^{1}FFT^{\left[ 1 \right]}\left( \frac{L+R}{2},R \right) $

- 其中$FFT^{\left[ 0/1 \right]}\left( L,R \right) $代表右矩阵的下标为奇数／偶数时子矩阵的$FFT\left( L,R \right) $

- $IFFT\left( L,R \right)$与此类似

**优化方法**

- 由于$FFT(L,R)$与$IFFT(L,R)$在实现上的相似性，可以合并以精简代码

- 可以发现，最后每个数的原编号是现编号的翻转，因此可以提前翻转

  ![](https://raw.githubusercontent.com/MrFoodinChina/Clouding/master/image/20190825210953.png)

- 将递归实现变为倍增实现

- 利用“蝴蝶操作”，在本地进行$FFT$，优化了中间暂存内存的消耗量

  ![](https://raw.githubusercontent.com/MrFoodinChina/Clouding/master/image/20190825211932.jpg)

### $NTT$数论变换／$INTT$数论逆变换

**理论基础**

- 模运算的原根$g$和原根的幂$g^n$与复数中的单位根等价
- 二者均为对应环下的一个单位元
- 所以$NTT$事实上是$FFT$在模运算下的实现

**常见模数**

|           模数           |        计算式         | 原根  |
| :----------------------: | :-------------------: | :---: |
|           $3$            |        $2^1+1$        |  $2$  |
|           $5$            |        $2^2+1$        |  $2$  |
|           $17$           |        $2^4+1$        |  $3$  |
|           $97$           |    $3\times 2^5+1$    |  $5$  |
|          $193$           |    $3\times 2^6+1$    |  $5$  |
|          $257$           |        $2^8+1$        |  $3$  |
|          $7681$          |   $15\times 2^9+1$    | $17$  |
|         $12289$          |  $3\times 2^{12}+1$   | $11$  |
|         $40961$          |  $5\times 2^{13}+1$   |  $3$  |
|         $65537$          |      $2^{16}+1$       |  $3$  |
|         $786433$         |  $ 3\times 2^{18}+1$  | $10$  |
|        $5767169$         |  $11\times 2^{19}+1$  |  $3$  |
|        $7340033$         |  $7\times 2^{20}+1$   |  $3$  |
|        $23068673$        |  $11\times 2^{21}+1$  |  $3$  |
|       $104857601$        |  $25\times 2^{22}+1$  |  $3$  |
|       $167772161$        |  $5\times 2^{25}+1$   |  $3$  |
|       $469762049$        |  $7\times 2^{26}+1$   |  $3$  |
|       $998244353 $       | $119\times 2^{23}+1$  | $ 3$  |
|      $1004535809 $       | $479\times 2^{21}+1 $ | $ 3$  |
|      $2013265921 $       | $15\times 2^{27}+1 $  | $31 $ |
|      $2281701377 $       | $17\times 2^{27}+1 $  | $3 $  |
|      $3221225473 $       |  $3\times 2^{30}+1 $  | $5 $  |
|     $  75161927681$      | $35\times 2^{31}+1 $  | $ 3$  |
|     $77309411329  $      |  $9\times 2^{33}+1 $  | $7 $  |
|     $ 206158430209 $     |  $3\times 2^{36}+1 $  | $22 $ |
|    $2061584302081  $     | $15\times 2^{37}+1 $  | $7 $  |
|    $ 2748779069441 $     |  $5\times 2^{39}+1 $  | $ 3$  |
|    $ 6597069766657 $     |  $3\times 2^{41}+1 $  | $5 $  |
|    $ 39582418599937 $    |  $9\times 2^{42}+1 $  | $5 $  |
|    $79164837199873  $    |  $9\times 2^{43}+1 $  | $5 $  |
|   $ 263882790666241 $    | $15\times 2^{44}+1 $  | $7 $  |
|    $1231453023109121$    | $35\times 2^{45}+1 $  | $ 3$  |
|    $1337006139375617$    | $19\times 2^{46}+1 $  | $3 $  |
|    $3799912185593857$    | $27\times 2^{47}+1 $  | $5 $  |
|   $4222124650659841  $   | $15\times 2^{48}+1 $  | $19 $ |
|    $7881299347898369$    |  $7\times 2^{50}+1 $  | $6 $  |
|  $ 31525197391593473 $   |  $7\times 2^{52}+1 $  | $ 3$  |
|  $ 180143985094819841 $  |  $5\times 2^{55}+1 $  | $6 $  |
| $  1945555039024054273 $ | $27\times 2^{56}+1 $  | $5 $  |
| $ 4179340454199820289 $  | $29\times 2^{57}+1 $  | $3 $  |

**$NTT$优化方法**

- 存下需要的原根的幂，空间换时间
- $FFT$常见优化

### $FWT$快速沃尔什变换／$IFWT$快速沃尔什逆变换

$FFT$／$NTT$可以解决$C_k=\sum_{k=i+k}A_iB_j$的快速计算问题，而$FWT$可以解决$C_k=\sum_{k=i*k}A_iB_j(*为任意的位运算)$的快速计算问题

$FWT$的原理为：通过分治将序列转化为与位运算有关的新序列，使得原来的卷积变为点积

<font size=4>**$FWT$对应表**</font>

| 位运算 | $0*0$ | $0*1=1*0$ | $1*1$ | $FWT$左项 | $FWT$右项 | $IFWT$左项 | $IFWT$右项 |
| :--------: | :---: | :-------: | :---: | :-------: | :-------: | :--------: | :--------: |
| 与 |  $0$  | $0$ | $1$ | $L+R$ | $R$ | $L-R$ | $R$ |
| 或 |   $0$   | $1$ | $1$ | $L$ | $L+R$ | $L$ | $R-L$ |
| 异或 |   $0$   | $1$ | $0$ | $L+R$ | $L-R$ | $\frac{L+R}{2}$ | $\frac{L-R}{2}$ |
| 与非 |   $1$   | $1$ | $0$ | $R$ | $L+R$ | $L$ | $R-L$ |
|   或非   | $1$ | $0$ | $0$ | $L+R$ | $L$ | $L-R$ |$R$|
| 同或 |   $1$   | $0$ | $1$ | $L+R$ | $R-L$ | $\frac{L-R}{2}$ | $\frac{L+R}{2}$ |



## 数论反演公式

**莫比乌斯反演**
$$
f\left( n \right) =\sum_{d\mid n}{g\left( d \right)}\iff g\left( n \right) =\sum_{d\mid n}{\mu \left( d \right) f\left( \frac{n}{d} \right)}
$$

**二项式反演**
$$
f\left( n \right) =\sum_{i=0}^n{\left( \begin{array}{c}
	n\\
	i\\
\end{array} \right) g\left( i \right)}\iff g\left( n \right) =\sum_{i=0}^n{\left( -1 \right) ^{n-i}\left( \begin{array}{c}
	n\\
	i\\
\end{array} \right) f\left( i \right)}\\
	f\left( k \right) =\sum_{i=k}^n{\left( \begin{array}{c}
	i\\
	k\\
\end{array} \right) g\left( i \right)}\iff g\left( k \right) =\sum_{i=k}^n{\left( -1 \right) ^{i-k}\left( \begin{array}{c}
	i\\
	k\\
\end{array} \right) f\left( d \right)}\\
	f\left( n \right) =\sum_{i=0}^n{\left( -1 \right) ^i\left( \begin{array}{c}
	n\\
	i\\
\end{array} \right) g\left( i \right)}\iff g\left( n \right) =\sum_{i=0}^n{\left( -1 \right) ^i\left( \begin{array}{c}
	n\\
	i\\
\end{array} \right) f\left( i \right)}\\
$$

**最值反演**
$$
Max\left\{ S \right\} =\sum_{T\subset S,T\ne \oslash}{\left( -1 \right) ^{\left| T \right|+1}Min\left\{ T \right\}}\\
	Min\left\{ S \right\} =\sum_{T\subset S,T\ne \oslash}{\left( -1 \right) ^{\left| T \right|+1}Max\left\{ T \right\}}\\
$$

**斯特林反演**
$$
f\left( n \right) =\sum_{i=1}^n{S_2\left( n,i \right) f\left( i \right)}\iff g\left( n \right) =\sum_{i=1}^n{\left( -1 \right) ^{n-i}S_1\left( n,i \right) f\left( i \right)}
$$

**子集反演**
$$
f\left\{ S \right\} =\sum_{T\subset S}{g\left\{ T \right\}}\iff g\left\{ S \right\} =\sum_{T\subset S}{\left( -1 \right) ^{\left| S-T \right|}f\left\{ T \right\}}
$$

**单位根反演（矩阵上仍成立）**
$$
f\left( x \right) =\frac{1}{n}\sum_{i=0}^n{\omega _{j}^{ix}}=\left[ n|x \right]\\
	F\left( x \right) =\sum_{i=0}^N{a_ix^i}\gets  \frac{1}{p}\sum_{i=0}^{p-1}{F\left( \omega _{p}^{i} \right)}=\sum_{i=0}^n{a_i\left[ p|i \right]}\\
$$

## 多项式计算方法

**多项式求逆**
$$
\left. \begin{array}{r}
	A\left( x \right) \cdot B\left( x \right) \equiv 1\left( mod\,\,x^n \right) \\\
	A\left( x \right) \cdot C\left( x \right) \equiv 1\left( mod\,\,x^{\lceil \frac{n}{2} \rceil} \right) \\
\end{array} \right\} \Longrightarrow B\left( x \right) \equiv 2C\left( x \right) -A\left( x \right) \cdot C^2\left( x \right) \left( mod\ x^n \right)
$$

**求导&积分**
$$
F\left( x \right) =\sum_{i=0}^{\infty}{a_ix^i}\Longrightarrow \left\{ \begin{array}{l}
	\int{F\left( x \right)}=C+\sum_{i=1}^{\infty}{\frac{a_{i-1}}{i}x^i}\\
	F'\left( x \right) =\sum_{i=0}^{\infty}{\left( i+1 \right) a_{i+1}x^i}\\
\end{array} \right.
$$

**取对数$\ln \  F\left( x \right)$**
$$
\ln\text{ }F\left( x \right) =\int{\frac{F'\left( x \right)}{F\left( x \right)}}
$$

**多项式复合**
$$
G\left( f_t\left( x \right) \right) \equiv 0\left( mod\ x^{2^t} \right) \Longrightarrow f_{t+1}\left( x \right) \equiv f_t\left( x \right) -\frac{G\left( f_t\left( x \right) \right)}{G'\left( f_t\left( x \right) \right)}\left( mod\ x^{2^{t+1}} \right)
$$

- 求指数$e^{F\left( x \right)}$：求解$G\left( f\left( x \right) \right) =\ln\text{ }f\left( x \right) -F\left( x \right) $

- 开多次方根$\sqrt[n]{F\left( x \right)}$：求解$G\left( f\left( x \right) \right) =f^n\left( x \right) -F\left( x \right) $

- 多项式快速幂$F^n\left( x \right)$：$F^n\left( x \right) \equiv e^{n\ln F\left( x \right)}\left( mod\ x^t \right) $

**多项式除法**
$$
F^{r\left( k \right)}\left( x \right) =x^k\cdot F\left( \frac{1}{x} \right) \Longrightarrow \lfloor \frac{A\left( x \right)}{B\left( x \right)} \rfloor \equiv \left( \frac{A^{r\left( n \right)}\left( x \right)}{B^{r\left( m \right)}\left( x \right)} \right) ^{r\left( n-m \right)}\left( mod\ x^{n-m+1} \right)
$$

## 生成函数（母函数）

**定义**

- 对数列$\left\{ a_i \right\} $，有生成函数$F\left( x \right) =\sum_{i=0}^{\infty}{a_ix^i}$
- 生成函数分为一般生成函数和指数生成函数

**运算意义**

- $A\left( x \right) +B\left( x \right) $：$A\cup B$的生成函数
- $A\left( x \right) -B\left( x \right) $：$A\cap B$的生成函数
- $A\left( x \right) \times B\left( x \right) $：$\left\{ \left( a,b \right) \mid a\in A,b\in B,size\left[ \left( a,b \right) \right] =\left| a \right|+\left| b \right| \right\} $的生成函数

**常见一般生成函数**

- 全$1$生成函数：$F\left( x \right) =\frac{1}{1-x}=\sum_{i=0}^{\infty}{x^i}$
- 非负整数生成函数：$F\left( x \right) =\frac{x}{\left( 1-x \right) ^2}=\sum_{i=0}^{\infty}{ix^i}$
- 组合数生成函数：$F_n\left( x \right) =\frac{1}{\left( 1-x \right) ^n}=\sum_{i=0}^{\infty}{C_{i+n-1}^{n-1}x^i}$
- 所有非负整数的平方：$F\left( x \right) =\frac{x\left( x+1 \right)}{\left( 1-x \right) ^3}=\sum_{i=0}^{\infty}{i^2x^i}$
- 斐波那契数生成函数：$F\left( x \right) =\frac{1}{1-x-x^2}=\sum_{i=0}^{\infty}{Fibonacci\left( i+1 \right) x^i}$
- 有序拆分方案数：$F\left( x \right) =\frac{x}{1-2x}=\sum_{i=0}^{\infty}{\lfloor 2^{i-1} \rfloor x^i}$
- 卡特兰数：$\begin{array}{c}
  	C_{n+1}=\left\{ \begin{array}{l}
    	1\qquad n=0\,\,or\,\,n=1\\
    	\sum_{i=0}^n{C_iC_{n-i}}\quad else\\
  \end{array} \right.\\
  	\Longrightarrow F\left( x \right) =\frac{1-\sqrt{1-4x}}{2x}=\sum_{i=0}^{\infty}{C_ix^i}\\
  \end{array}$

**部分一般生成函数公式**
$$
\begin{array}{c}
	A_{n,k}=\left\{ \begin{array}{l}
	1\qquad k=1\ or\ k=n\\
	kA_{n-1,k}+\left( n+2-k \right) A_{n-1,k-1}\quad else\\
\end{array} \right.\\
	\Longrightarrow F_n\left( x \right) =\frac{xA_n\left( x \right)}{\left( 1-x \right) ^{n+1}}=\frac{x\sum_{i=1}^n{A_{n,i}x^{i-1}}}{\left( 1-x \right) ^{n+1}}=\sum_{i=0}^{\infty}{i^nx^i}\\
\end{array}
$$

$$
f_n=\sum_{i=1}^m{a_if_{n-i}}\Longrightarrow F\left( x \right) =\frac{1}{1-\sum_{i=1}^m{a_ix^i}}
$$

$$
F\left( x \right) =\sum_{i=0}^{\infty}{A^i\left( x \right)}\Longrightarrow F\left( x \right) =\frac{1}{1-A\left( x \right)}
$$

**常见指数生成函数**

- 全$1$生成函数：$F\left( x \right) =e^x=\sum_{i=0}^{\infty}{\frac{x^i}{i!}}$

- 阶乘生成函数：$\begin{array}{c}
  	F\left( x \right) =\ln \left( 1+x \right) =0+\sum_{i=1}^{\infty}{\frac{\left( -1 \right) ^{i-1}}{i}x^i}\\
    	G\left( x \right) =-\ln \left( 1-x \right) =0+\sum_{i=1}^{\infty}{\frac{x^i}{i}}\\
  \end{array}$
  
- 伯努利数：$\begin{array}{c}
  	B_n=\left\{ \begin{array}{l}
    	1\qquad n=0\\
    	-\frac{\sum_{i=0}^{n-1}{C_{n+1}^{i}B_i}}{C_{n+1}^{n}}\quad else\\
  \end{array} \right.\\
  	\Longrightarrow F\left( x \right) =\frac{x}{e^x-1}=\sum_{i=0}^{\infty}{\frac{B_ix^i}{i!}}\\
  \end{array}$
  
- 三角函数：$\begin{array}{c}
   	F\left( x \right) =\sin \left( x \right) =\sum_{i=0}^{\infty}{\frac{\left( -1 \right) ^ix^{2i+1}}{\left( 2i+1 \right) !}}\\
      	G\left( x \right) =\cos \left( x \right) =\sum_{i=0}^{\infty}{\frac{\left( -1 \right) ^ix^{2i}}{\left( 2i \right) !}}\\
      	H\left( x \right) =\sin\text{h}\left( x \right) =\sum_{i=0}^{\infty}{\frac{x^{2i+1}}{\left( 2i+1 \right) !}}\\
      	K\left( x \right) =\cos\text{h}\left( x \right) =\sum_{i=0}^{\infty}{\frac{x^{2i}}{\left( 2i \right) !}}\\
   \end{array}$
   
- 组合数生成函数：$F_n\left( x \right) =\left( 1+x \right) ^n=\sum_{i=0}^n{\frac{n!}{i!\left( n-i \right) !}x^i}$

<div STYLE="page-break-after: always;"></div>
# 网络流算法

**写在前面**

- 所有算法都默认含反向边
- $Dinic$算法使用了增广路方法
- $HLPP$算法与$ISAP$算法使用了预流推进算法

## 最大流算法

<font size=4>**$Dinic$算法**</font>

**实现步骤**

1. 对原图进行$BFS$，得出源点到每个点的简单最短距离$Dis$
2. 按$Dis$每次递增$1$的方式$DFS$遍历全图，并更新增广路
3. 重复步骤1~2，直到再也找不到增广路为止

**当前弧优化**

- 由于在遍历一个点的出边的顺序是固定的
- 所以在一条边成为满流边后，在此之前的所有边都已经满流
- 因此可以记录下每个点第一个未满流边，$DFS$时直接从这里开始即可
- 注意：在每次$DFS$结束后要将记录初始化

**适配费用流的改动**

- 将$BFS$中的$Dis$值改为从源点到所在点的最小总费用
- $DFS$过程中要记录某节点是否在路径上，防止出现循环$DFS$

**时间复杂度**

- 绝大部分数据中，时间复杂度为$\varTheta \left( n^2m \right) $
- 特殊的，在具有单位容量的网络中，时间复杂度为$\varTheta \left( \min(\sqrt m,n^\frac{2}{3})m \right) $
- 更特殊的，在最大二分图匹配中，时间复杂度为$\varTheta \left( m\sqrt n \right) $

<font size=4>**$ISAP$算法**</font>

**实现步骤**

1. 对原图的反向图进行$BFS$，记录每个点到汇点的简单最短距离$Dis$
2. 对原图按$Dis$每次递减$1$的方式$DFS$，并且更新增广路
3. 当这个点的入流大于总出流时（源点入流$=\infty $），进行$Dis_u+1\gets  Dis_u$
4. 重复步骤2~3，直到$Dis$值出现断层（无法再$DFS$）时结束
5. 同$Dinic$算法可进行当前弧优化

<font size=4>**$HLPP$算法**</font>

**原始预流推进算法**

1. 每个点设一个高度值$Height$和余流值$Water$
2. 源点初始化为$Height_s=N\quad Water_s=\infty $，其他点为$Height=0\quad Water=0$
3. 按队列顺序选择一个有余流的中间节点$u$，进行$Height_u\gets  Min\left\{ Height_v\ \left( u,v \right) \in E \right\} +1$
4. 对每一个$v\quad \left( u,v \right) \in E\ and\ f\left( u,v \right) >0$，尽可能地转移$Water$
5. 重复步骤3~4，当中间节点均满足$Water=0$时结束

**$HLPP$相比于原始预流推进的改进**

1. 对原图的反向图进行$BFS$，将$Height$初始化为到汇点的距离（除源点）
2. 以高度为关键字对节点建优先队列，进行上文步骤3~5

**$HLPP$的优缺点**

- 优点：时间复杂度较优：原始版本：$\varTheta \left( n^2m \right) $；$HLPP$：$\varTheta \left( n^2\sqrt{m} \right)$

- 缺点：常数比$Dinic$算法与$ISAP$算法更大

## 二分图匹配

二分图即为可分为两个独立集的图

最大二分图匹配问题即为在两个独立集之间两两配对，使得匹配点之间有连边，求最大匹配数

### 最大流算法

![](https://raw.githubusercontent.com/MrFoodinChina/Clouding/master/image/20190825204553.png)

类似上图所示，将源点向所有$A$集合的点连一条容量为$1$的边，所有$B$集合的点向汇点连边，再按原二分图的方式从$A$集合向$B$集合连边，最后这张图的最大流则为最大匹配数

时间复杂度因使用的最大流算法不同而在$\varTheta \left( m\sqrt n \right) $、$\varTheta \left( n^2\sqrt{m} \right)$到$\varTheta \left( n^2m \right)$、$\varTheta \left( nm^2 \right)$间波动

### 匈牙利算法

匈牙利算法是一种可以在$\varTheta \left( n^3 \right)$内解决二分图匹配问题的算法，其核心思想为“推翻——重构”

**算法实现**

1. 枚举待匹配顶点$x$与$x$所匹配的顶点$y$
2. 若$y$有匹配的顶点，那么对$y$配对的顶点重新匹配至其他顶点
3. 若所有被破坏配对的顶点都能够与一个新顶点配对，则记录此次“推翻——重构”
4. 当枚举完所有的$x$后，此时所有的配对则为最大二分图匹配的一组解




<div STYLE="page-break-after: always;"></div>
# 字符串算法

## $AC$自动机

- $AC$自动机是$Trie$树和$KMP$算法的结合
- $AC$自动机多用于多个字符串的匹配问题

**构造方法**

- 建立原数据的$Trie$树，然后对这个$Trie$树进行$BFS$
- 对每一个扫描到的结点，都按$KMP$算法更新$fail$指针

## 后缀数组

**内部操作变量**

- 排名第$i$大的后缀的序号$SA[i]$
- 第$i$个后缀的排名$Mark[i]$
- 第$(i-1)$名和第$i$名后缀的最长公共前缀长$Height[i]$

**变量维护方法**

- $SA[i]$：若较每一个后缀的长度为$N$的前缀，则可倍增出$2N$时的结果
- $Mark[i]$：在$SA[i]$计算完成后扫描$SA$数组即可
- $Height[i]$：引理：$Height\left[ i \right] \ge Height\left[ i-1 \right] -1$

## 后缀自动机
- 后缀自动机是接受一个字符串所有后缀的最小确定性有限状态自动机
- 后缀自动机的转移图为有向无环图，所有状态均可由唯一的源点$s$到达
- 每个状态都代表原串的一个子串集合，每个转移都含有一个字符

**后缀自动机关联数据**

- 原字符串$String$
- 状态所代表的字符串集合中最长字符串的长度$Len$（实际不存储）
- 指向代表所在状态对应字符串的后缀的集合对应状态的指针$Fail$
- 所在状态的状态转移集合$Move$
- 上一个加入字符所在状态$Last$

**构造方法**

1. 加入字符$c=String[i]$，并创建状态$note$
2. 初始化$Len[note]\gets  i\quad Fail[note]\gets  NULL$
3. 从$Last$按照$Fail$向上回溯，当$Move[c]=NULL$时进行$Move[c]\gets  note$
4. 当回溯到$NULL$时，进行$Fail[note]\gets  s$，然后退出循环至步骤10
5. 当回溯到$Move[c]\ne NULL$时，设此时在状态$p$，$Move[c]=q$
6. 若$Len[q]=Len[p]+1$，进行$Fail[note]\gets  q$，然后退出循环至步骤10
7. 否则将状态$q$复制到状态$clone$，并初始化$Len[clone]\gets  Len[p]+1$
8. 进行$Fail[note]\gets  clone \quad Fail[q] \gets  clone$
9. 从$p$进行$Move[c]\gets  clone$，然后退出循环至步骤10
10. 进行$Last\gets  note$，然后重复步骤1~9，直到原串被全部加入

<div STYLE="page-break-after: always;"></div>
# 计算几何

## 向量基础操作

<font size=5>**点积**</font>

**代数定义**
$$
	\overrightarrow{A}=\left< a_1,a_2,\cdots ,a_n \right> \qquad \overrightarrow{B}=\left< b_1,b_2,\cdots ,b_n \right>\\
	\Longrightarrow \overrightarrow{A}\cdot \overrightarrow{B}=a_1b_1+a_2b_2+\cdots +a_nb_n\\
$$

**几何定义**

$\overrightarrow{A}$在$\overrightarrow{B}$上投影与$\left| \overrightarrow{B} \right|$的乘积（可类比为于$\overrightarrow{A}$与$\overrightarrow{B}$的“相似程度”）

**性质**

- 交换律：$$\overrightarrow{A}\cdot \overrightarrow{B}=\overrightarrow{B}\cdot \overrightarrow{A}$$
- 与数乘的结合律：$$\left( k\overrightarrow{A} \right) \cdot \overrightarrow{B}=\overrightarrow{A}\cdot \left( k\overrightarrow{B} \right) =k\left( \overrightarrow{A}\cdot \overrightarrow{B} \right) $$
- 分配率：$$\left( \overrightarrow{A}+\overrightarrow{B} \right) \cdot \overrightarrow{C}=\overrightarrow{A}\cdot \overrightarrow{C}+\overrightarrow{B}\cdot \overrightarrow{C}$$

<font size=5>**叉积**</font>

**代数定义**

- 二维定义

$$
	\overrightarrow{A}=\left( x_A,y_A \right) \quad \overrightarrow{B}=\left( x_B,y_B \right)\\
	\Longrightarrow \overrightarrow{A}\times \overrightarrow{B}=x_Ay_B-x_By_A\\
$$



- 三维定义

$$
	\overrightarrow{A}=\left( x_A,y_A,z_A \right) \quad \overrightarrow{B}=\left( x_B,y_B,z_B \right)\\
	\Longrightarrow \overrightarrow{A}\times \overrightarrow{B}=\left| \begin{matrix}
	\vec{i}&		\vec{j}&		\vec{k}\\
	x_A&		y_A&		z_A\\
	x_B&		y_B&		z_B\\
\end{matrix} \right|=\left( y_Az_B-y_Bz_A \right) \vec{i}+\left( z_Ax_B-z_Bx_A \right) \vec{j}+\left( x_Ay_B-x_By_A \right) \vec{k}\\
$$

**几何定义**

- 二维定义：$与$$\overrightarrow{B}$所围成的三角形的有向面积
- 三维定义：满足以下条件的一个“伪”向量
  - 垂直于$\overrightarrow{A}$与$\overrightarrow{B}$所决定的平面
  - 指向按右手定则从$\overrightarrow{A}$转向$\overrightarrow{B}$来确定
  - 长度等于以$\overrightarrow{A}$与$\overrightarrow{B}$为邻边组成的平行四边形的面积

**性质**

- 反交换律：$\vec{A}\times \vec{B}=-\vec{B}\times \vec{A}$
- 与数乘的结合律：$\left( k\vec{A} \right) \times \vec{B}=\vec{A}\times \left( k\vec{B} \right) =k\left( \vec{A}\times \vec{B} \right) $
- 分配律：$\left( \vec{A}+\vec{B} \right) \times \vec{C}=\vec{A}\times \vec{C}+\vec{B}\times \vec{C}$
- 雅可比恒等式：$\vec{A}\times \left( \vec{B}\times \vec{C} \right) +\vec{B}\times \left( \vec{C}\times \vec{A} \right) +\vec{C}\times \left( \vec{A}\times \vec{B} \right) =0$

<font size=5>**基础操作**</font>

- 向量夹角$\cos \left< \vec{A},\vec{B} \right> =\frac{\vec{A}\cdot \vec{B}}{\left| \vec{A} \right|\left| \vec{B} \right|}$
- 二维向量旋转（逆时针）：$\vec{B}=\left\{ \begin{array}{l}
  ​	\left( x_A\cos \theta -y_A\sin \theta ,x_A\sin \theta +y_A\cos \theta \right)\\
  ​	\vec{A}\times \left( \begin{matrix}
  ​	\cos \theta&		\sin \theta\\
  ​	-\sin \theta&		\cos \theta\\
  \end{matrix} \right)\\
  \end{array} \right.$
- $\overrightarrow{A}$在$\overrightarrow{B}$方向上的投影：$\vec{C}=\frac{\left( \vec{A}\cdot \vec{B} \right) \vec{B}}{\left| \vec{B} \right|^2}\qquad \left| \vec{C} \right|=\frac{\vec{A}\cdot \vec{B}}{\left| \vec{B} \right|}$
- 直线点向式：$\vec{p}=\left( x_0,y_0 \right) \quad \vec{v}=\left( B,-A \right)\\
  	\Longrightarrow \vec{p}+t\vec{v}\in Ax+By+C=0\\
    	\Longrightarrow Ax+By+C=0\left( \vec{p},\vec{v} \right)\\$
- 两直线交点：$l_1=\left( \overrightarrow{p_1},\overrightarrow{v_1} \right) \quad l_2=\left( \overrightarrow{p_2},\overrightarrow{v_2} \right)\\
  	\Longrightarrow \vec{O}=\frac{\left( \overrightarrow{p_2}-\overrightarrow{p_1} \right) \times \overrightarrow{v_2}}{\overrightarrow{v_1}\times \overrightarrow{v_2}}\overrightarrow{v_1}+\overrightarrow{p_1}\\$
- 点到直线垂足：$	\vec{P}=\left( x,y \right) \quad l=\left( \vec{Q},\vec{v} \right)\\
  	\Longrightarrow \vec{H}=\frac{\left( \vec{Q}-\vec{P} \right) \cdot \vec{v}}{\left| \vec{v} \right|^2}\vec{v}+\vec{P}\\$
- 点到直线距离：求垂足得距离／利用叉积
- 向量角平分线：利用等腰三角形的中线／利用向量旋转
- 平面反射：利用向量旋转
- 三维空间中平面表示：由点$P\in S$与$S$的法向量$\vec{n}$表示，记作$S=\left(\overrightarrow{Q},\overrightarrow{n} \right) $

<font size=4>**二维基础操作**</font>

**三角形剖分**

- 有向三角形剖分：任选⼀个起点$O$，将多边形剖分为若干有向三角形
- 无向三角形剖分：每次将多边形的⼀个子三角形划分为⼀个新的三角形

**多边形面积**

1. 将多边形三角剖分
2. 计算每个有向三角形的有向面积之和

**多边形重心**

1. 将多边形进行有向三角剖分
2. 求出每个三角形的质量和重心
3. 利用杠杆原理合成出原多边形的重心

**判断点与多边形位置关系**

- 射线法
  - 过点做⼀条射线，求这条射线与多边形的边相交的次数
  - 若次数为奇数次，则点在多边形内
  - 若次数为偶数次，则点在多边形外
- 面积法
  - 计算以这个点为原点求多边形的有向面积
  - 计算有向剖分后每个三角形的面积的绝对值之和
  - 若两者相等，则点在多边形内
- 环路法
  - 以这个点为原点，计算有向剖分后每个三角形原点对应的角度之和
  - 如果和为$0$则点在多边形外，反之则点在多边形内

- 算法比较

|  算法  |                        优点                        |        缺点        |
| :----: | :------------------------------------------------: | :----------------: |
| 射线法 | 静态查询可以做到$\varTheta \left( \log\ n \right)$ | 射线可能会与边重合 |
| 面积法 |                      较为方便                      |  只适用于凸多边形  |
| 环路法 |                      较为方便                      | 点可能会在多边形上 |

**求圆点切线**

1. 利用反三角函数计算出切线之间的夹角
2. 利用勾股定理计算出点心距
3. 将点到圆心之间的向量进行一定旋转放缩即得

**求圆圆切线**

1. 利用反三角函数计算出切线与两心连线之间的夹角
2. 利用圆点切线的方法计算出切线
3. 切点可由原点到圆心向量与修正向量的和得出

**求圆线交点**

1. 求出圆心到直线的垂足
2. 利用勾股定理计算出交点到垂足的距离
3. 通过两个计算结果得出两个圆线交点

**圆圆交点**

1. 利用余弦定理解出交点与一圆心到另一圆心的夹角
2. 将两圆心之间的向量进行旋转放缩即可

**三点定圆**

- 方法一：作中垂线求交点
- 方法二：解关于圆心的方程

<font size=4>**三维基础操作**</font>

**三点定平面**

- 由于三维下叉积方向的几何定义为垂直于两个向量的“伪”向量
- 所以求出三点构成的两个向量的叉积就可以确定这个平面的⼀个法向量

**混合积**

- 混合积可以求出它们确定的平行六面体的有向体积
- 其中有向体积方向遵循右手定则

$$
\left[ \begin{matrix}
	v_1&		v_2&		v_3\\
\end{matrix} \right] =\left| \begin{matrix}
	x_1&		y_1&		z_1\\
	x_2&		y_2&		z_2\\
	x_3&		y_3&		z_3\\
\end{matrix} \right|
$$

**点到平面的距离**

​		点$P$到平面$S=\left( \overrightarrow{Q},\overrightarrow{n} \right) $的距离为$$d=\frac{\left( \overrightarrow{P}-\overrightarrow{Q} \right) \cdot \overrightarrow{n}}{\left| \overrightarrow{n} \right|}$$

**两直线最短距离**
$$
	l_1\parallel l_2\Longrightarrow d_{l_1-l_2}=d_{P-l_2}\left( P\in l_1 \right)\\
	l_1\cap l_2\ne \varnothing \Longrightarrow d_{l_1-l_2}=d_{P-S}\left( P\in l_1,l_2\subset S,l_3\subset S,l_1\parallel l_3 \right)\\
$$

**线面交点**

​		类似于二维平面的直线交点
$$
	l=\left( \vec{P},\vec{v} \right) \qquad S=\left( \vec{Q},\vec{n} \right)\\
	\Longrightarrow \vec{O}=\frac{\left( \vec{Q}-\vec{P} \right) \cdot \vec{n}}{\vec{v}\cdot \vec{n}}\vec{v}+\vec{P}\\
$$

**三平面交点**
$$
	S_1=\left( \vec{P}_1,\vec{n}_1 \right) \quad S_2=\left( \vec{P}_2,\vec{n}_2 \right) \quad S_3=\left( \vec{P}_3,\vec{n}_3 \right)\\
	\Longrightarrow \vec{O}=\frac{\left( \vec{P}_1\cdot \vec{n}_1 \right) \left( \vec{n}_2\times \vec{n}_3 \right) +\left( \vec{P}_2\cdot \vec{n}_2 \right) \left( \vec{n}_3\times \vec{n}_1 \right) +\left( \vec{P}_3\cdot \vec{n}_3 \right) \left( \vec{n}_1\times \vec{n}_2 \right)}{\left| \begin{matrix}
	x_{\vec{n}_1}&		y_{\vec{n}_1}&		z_{\vec{n}_1}\\
	x_{\vec{n}_2}&		y_{\vec{n}_2}&		z_{\vec{n}_2}\\
	x_{\vec{n}_3}&		y_{\vec{n}_3}&		z_{\vec{n}_3}\\
\end{matrix} \right|}\\
$$

**两平面交线**

- 交线的方向向量：两平面的法向量叉积
- 交线上任意⼀点：类似于三平面相交，解出任意一组解即可

## 凸包

**定义**

- 对点集$D$，有唯一点集$S\subseteq D$，使得：

- $S$可以构建一个凸形，且所建凸形覆盖了点集$D$中所有点
- 此时$S$则为$D$的凸包

**二维构建方法**

- $Ronald\ Graham$法
  1. 找到所有点中纵坐标最小的点
  2. 将其他所有点按照与这个点连线的极角排序
  3. 一遍扫过去，用单调栈维护答案
- $Boshi\ An$法
  1. 找到所有点中横坐标最小的点
  2. 从步骤1的点开始向横坐标更大且斜率最小点转移，维护下凸包
  3. 从步骤1的点开始向横坐标更大且斜率最大的转移，维护上凸包
  4. 合并上凸包与下凸包

**三维构建方法：增量法**

1. 每次加入一个点
2. 如果此点已经在已有凸包内，跳过此点
3. 否则，扫描所有凸包上的点，将会被新点“挡住”的点剔除

## 旋转卡壳

**构造方法**

1. 计算出原有点集的凸包
2. 枚举出凸包的其中一对对跖点
3. 对所求对跖点更新答案
4. 向一个方向旋转，寻找下一对对跖点（就是凸包上下一个点）

**作用算法**

- 求凸多边形间最近／远距离
- 求最小外接矩形

## 半平面交

**半平面交定义**

- 代数定义：不等式形式均为$Ax+By+C\ge 0$的不等式组的解集
- 几何定义：给定若干有向直线，求所有有向直线的左／右侧点的并集

**计算方法**

1. 将半平面按照代表有向直线的方位角排序
2. 依次考虑每个半平面会不会覆盖之前的半平面
3. 用双向队列维护答案半平面的代表向量集合
4. 每次仅需检查新加入的半平面是否包含队头／队尾两条向量的交点
5. 在所有半平面加入后，检查队头与队尾的冲突关系

**注意事项**

- 按方位角排序后若有同向平行的半平面，只保留最内侧的
- 如果采用上文步骤4的“交点与直线位置关系”判断，则需保证答案封闭
- 若所有半平面没有交，该算法将返回不超过$2$个半平面

## 最小圆／球覆盖

**概念**

​		已知点集$D$，求可以覆盖其中所有点的最小圆

**计算方法**

1. 每次增加一个点$A$，若点$A$在答案圆外，进行步骤2~4
2. 将答案圆设为仅包含点$A$，半径为$0$的圆（实际上就是一个点）
3. 遍历$A$前所有点，若有点$B$在答案外，将答案更新为$A,B$为直径的圆
4. 再遍历$B$之前所有点，若有点$C$在答案外，将答案更新为$A,B,C$三点共圆
5. 回到步骤3，继续找符合条件的点$B$

**注意事项**

- 由于算法的时间复杂度为期望值，所以使用前要随机化

**最小球覆盖**

- 最小球覆盖与最小圆覆盖在算法实现上相似，只是细节差别
- 注意：三点不能确定一个球，需四点共球

## 平面图

> 设有平面图（无交叉点的二维图）$G$，其点/边/面集分别为$V,E,F$

**平面图定理**
$$
\left| V \right|+\left| F \right|-\left| E \right|=1+k\qquad k\text{为连通分支数}
$$

$$
\left| E \right|\le 3\left| V \right|-6
$$

$$
\exists P\in V\quad \left| Connect\left( P \right) \right|\le 5
$$

**平面图判定**

- 一个图为平面图当且仅当其不包含与$K_5$或$K_{3,3}$同胚的子图
- 一个图为平面图当且仅当其不包含可收缩为$K_5$或$K_{3,3}$的子图

**对偶图**

- 将原图中的面视作对偶图的点
- 将原图中的边两侧的面相连，视作对偶图的边

**平面图分治**

例题及答案：

- 给定一个凸包和其三角剖分，边上有权值，求是否存在最短距离为$K$的点
- 每次找到最中心的线段，分别以两端点为起点走最短路

## 扫描线

**矩形扫描线**

1. 将矩形左右端按照横坐标排序，从左往右扫描
2. 用线段树维护纵坐标上的数据

**扇形扫描线**

1. 将扇形按照半径排序，从内到外扫描
2. 用线段树维护极角上的数据

## $Simpson$积分

- $Simpson$积分是一种定积分的算法，可以用来求不规则图形面积
- $Simpson$积分的原理是利用二次函数来拟合当前函数

$$
\int_L^R{F\left( x \right) dx}\approx \frac{R-L}{6}\left[ F\left( L \right) +4F\left( \frac{L+R}{2} \right) +F\left( R \right) \right]
$$

- 递归终点：$\int_L^R{F\left( x \right) dx}\approx \int_L^{\frac{L+R}{2}}{F\left( x \right) dx}+\int_{\frac{L+R}{2}}^R{F\left( x \right) dx}$
- 需要强制递归几层，防止有极大点干扰结果

<div STYLE="page-break-after: always;"></div>
# 动态规划

## 背包问题

<font size=5>**$01$背包问题**</font>

**基本形式**

- 有$N$个不可拆分的物品和一个容量为$V$的背包
- 每个物品在背包中所占体积为$C_i$，得到价值为$W_i$
- 求解将哪些物品装入背包可使价值总和最大

**状态转移方程**
$$
F_{i,v}=\left\{ \begin{array}{l}
	\max \left( F_{i-1,v},F_{i-1,v+C_i}+W_i \right) \quad v\in \left[ 0,V-C_i \right]\\
	F_{i-1,v}\qquad else\\
\end{array} \right. 
$$

**空间&时间常数&扩展优化**

- 空间优化：

  - 由于每一次的状态转移都只使用了上一个物品的答案
  - 所以可以只存储上一个与这一个物品的答案，减小所需内存量

- 时间常数优化：

  - $v$的分界点区间可由$\left(V-C_i\right)$优化为$\min \left( V-C_i,\sum_{j=i}^N{W_j} \right)$

- 支持“背包完全装满”条件：

  - 当不需要让背包完全装满时，将所有值均初始化为$0$
  - 否则，仅把背包完全空时初始化为$0$，其他均初始化为$-\infty$

<font size=5>**完全背包问题**</font>

**基本形式**

- 有$N$种不可拆分的物品和一个容量为$V$的背包，每种物品有无限多个
- 每种物品的每个个体在背包中所占体积为$C_i$，得到价值为$W_i$
- 求解怎样将这些物品装入背包可使价值总和最大

**状态转移方程**
$$
F_{i,v}=\left\{ \begin{array}{l}
	\max \left\{ F_{i-1,v},F_{i-1,v+kC_i}+kW_i\left( v+kC_i\le V \right) \right\} \quad v\in \left[ 0,V-C_i \right]\\
	F_{i-1,v}\qquad else\\
\end{array} \right.
$$

**空间&时间优化**

- 空间优化：同$01$背包的空间优化

- 时间优化：

  - 改变状态转移方程，从而利用前面的结果优化时间复杂度：

$$
F_{i,v}=\left\{ \begin{array}{l}
	\max \left( F_{i-1,v},F_{i,v+C_i}+W_i \right) \quad v\in \left[ 0,V-C_i \right]\\
	F_{i-1,v}\qquad else\\
\end{array} \right.
$$

  - 若有物品$i$比物品$j$更“价廉物美”，则物品$j$可忽略
  - 按照多重背包的方法优化

<font size=5>**多重背包问题**</font>

**基本形式**

- 有$N$种不可拆分的物品和一个容量为$V$的背包，某种物品有$S_i$个
- 每种物品的每个个体在背包中所占体积为$C_i$，得到价值为$W_i$
- 求解怎样将这些物品装入背包可使价值总和最大

**状态转移方程**
$$
F_{i,v}=\left\{ \begin{array}{l}
	\max \left\{ F_{i-1,v},F_{i-1,v+kC_i}+kW_i\left( v+kC_i\le V\ and\ k\le S_i \right) \right\} \quad v\in \left[ 0,V-C_i \right]\\
	F_{i-1,v}\qquad else\\
\end{array} \right.
$$

**时间复杂度优化**

1. 将$S_i$分为$1,2,4\cdots2^{k-1}\ and\ S_i+1-2^{k}\left( 0\le S_i+1-2^{k}<2^{k}-1\le S_i \right) $
2. 按$S_i$的分配加入相当于原物品的对应倍数的单个物品
3. 用加入物品集合代替原来的这一种物品，然后进行$01$背包算法

<font size=5>**混合背包问题**</font>

**基本形式**

- 有$N$种不可拆分的物品和一个容量为$V$的背包
- 一部分物品只有一个，一部分物品有无限个，剩下的每种物品有有限个
- 求解怎样将这些物品装入背包可使价值总和最大

**算法实现**

- 对每种物品按类型分别进行$01$背包、完全背包和多重背包的状态转移
- 对每种算法，都可以进行对应算法的优化

<font size=5>**二维费用的背包问题**</font>

**基本形式**

- 每件物品均具有两种不同的费用，选择这件物品必须同时付出这两种费用
- 对于每种费用都有一个可付出的最大值（即背包容量）
- 求怎样选择物品可以得到最大的价值

**算法实现**

- 费用加了一维只需状态也加一维即可
- 状态转移方程与$01$背包相似
- 实则等价于成复整数域上的背包问题

<font size=5>**分组背包问题**</font>

**基本形式**

- 有$N$组不可拆分的物品和一个容量为$V$的背包，每组物品有$S_i$个子物品
- 每个子物品在背包中所占体积为$C_i$，得到价值为$W_i$
- 同组物品不能同时选择
- 求解怎样将这些物品装入背包可使价值总和最大

**状态转移方程**
$$
F_{i,v}= \left\{ \begin{array}{l}
	\max \left( F_{i-1,v},\left\{ F_{i-1,v+C_j}+W_j \right\} \right) \quad v\in \left[ 0,V-C_j \right] ,j\in \left\{ S_i \right\}\\
	F_{i-1,v}\qquad else\\
\end{array} \right.
$$

**时间优化**

- 同组物品内可忽略更不“价廉物美”的物品
- 可进行类似于完全背包第二种优化的优化

<font size=5>**树形背包问题**</font>

**基本形式**

- 有$N$个不可拆分，互相有依赖关系的物品和一个容量为$V$的背包
- 每个物品依赖最多一个物品（即必须选择依赖物品才能选此物品）
- 物品的依赖关系可构成森林，其中每个物品依赖其父亲
- 每个物品在背包中所占体积为$C_i$，得到价值为$W_i$
- 求解怎样将这些物品装入背包可使价值总和最大

**算法实现**

- 将依赖树中每一棵子树都看成一个泛化物品
  - 泛化物品指花费$C$可变，且价值$W$为关于$C$的函数的物品
- 在向上回溯时将子树所代表的泛化物品合并
- 最后输出森林中所有树的泛化物品的合并

<font size=5>**背包问题的变式**</font>

**输出最优方案**

- 输出任意方案：计算背包时加入回溯指针，用链表倒序记录方案
- 输出字典序最小方案：当出现总价值相同的情况时，选择字典序最小方案

**输出方案总数**

- 输出所有方案数：将所有状态转移方程的$\max$，全部改为$sum$即可

- 输出最优方案数：记录不同状态下的方案总数，与最优方案一起更新即可

**求第$K$优解**

- 每次计算背包时同时记录最优解到第$K$优解

- 状态转移时将取最大值变为有序队列合并


## 动态规划优化

<font size=5>**单调队列&单调栈优化**</font>

- 单调队列和单调栈是队列与栈的优化
- 二者通过删除队尾／栈顶元素来维护内部元素的单调性
- 通过二者的单调性，可快速求出区间最值，从而加速状态转移

<font size=5>**斜率优化**</font>

- 斜率优化是计算几何算法（主要是凸包算法）在动态规划上的运用
- 斜率优化多运用在状态转移条件包含转移的始末点，不满足单调性的情况
- 将状态转移方程变形为关于某直线的斜率的条件，再用凸包与二分求解

<font size=5>**四边形不等式优化**</font>

- 四边形不等式优化是一种通过四边形不等式来优化区间类动态规划的方法
- 使用要求：$\begin{array}{c}
  	F_{L,R}=\underset{k=L}{\overset{R}{\max}}\left\{ F_{L,k}+F_{k+1,R} \right\} +W_{L,R}\\
    	其中L\le L'\le R'\le R\Rightarrow   W_{L',R'}\le W_{L,R}\\
  \end{array}$
- 四边形不等式：$L\le L'\le R\le R'\Rightarrow   W_{L,R}+W_{L',R'}\le W_{L,R'}+W_{L',R}$
- 定理：若$W$满足四边形不等式，则$F$满足四边形不等式
- 通过上述定理，可以直接利用贪心状态转移优化动态规划

<font size=5>**状态设计优化**</font>

- 状态转移优化指通过改变状态的定义来改变状态转移方程及其效率
- 这类优化大多不具有通用性，即不能举一反三地应用于多个题目中

**求字符串$S$和$T$的最长公共子序列**

- 当$\left| S \right|$较大，但$\left| T \right|$较小时，可以改变原有的$Ans=F_{\left| S \right|,\left| T \right|}$定义
- 定义$\left| S' \right|=F_{\left| T' \right|,Ans}$为与$T'$的最长公共子序列长度为$Ans$的最小$\left| S' \right|$
- 预处理出$S$每一位之后的任意字符出现的最早位置
- 结合$F$定义与$S$的转移指针，得出答案

**求无权有向图中是否存在哈密顿回路**

- 由于哈密顿回路的判定是$NP$类问题，所以只能直接记忆化搜索
- 正常的定义为$F_{S,i}$代表仅经过$S$中的点是否有路径$1\leadsto i$
- 在点数$N$略大时原有定义较慢，所以要用状态压缩的方式加速
- 定义$F_S$为代表仅经过$S$中的点能够到达点的集合
- 在压缩完状态和转移矩阵后，效率即可加快

## 插头$DP$

- 插头$DP$是一种与方格相关的动态规划形式
- 多用于与回路覆盖方案数相关的问题

计算方法：

- 定义插头为在已有区域中已经连接的区域的边界
- 将插头分为左插头和右插头，代表与相连接的插头的相对位置
- 按照从左向右的方式描述现有边界的插头情况（压缩为三进制数）
- 存储在$Hash$表或`std::map`内，然后进行状态转移

## 数位$DP$

- 数位$DP$是在$N$进制下对每一个非负整数的动态规划
- 一般情况下需要在状态转移中有数位的存在

计算方法：

- 将已有数字与其前缀相联系，形成状态转移方程
- 从$0$开始一直向目标转移，直到达到目标

<div STYLE="page-break-after: always;"></div>
# 其他算法

## 树链剖分

**实现思路**

- 将一棵树变为深度递增链的集合，然后用线段树快速维护
- 每次选择所需子树均选择最大子树，以最好地加速

**构建方法**

- $DFS$计算出所有节点的深度$Height$与子树大小$Size$
- 按$Size$为优先级再次$DFS$，并记录此时的$DFS$序$Dis$
- 记录下每个$Dis$对应的节点序号$Mark$
- 扫描$Mark$，将位置连续且$Dis$连续的数据用线段树维护

## 普通分治算法

**基本思想**

- 把一个复杂的问题分成两个或更多的相同或相似的子问题
- 直到子问题可以简单的直接求解
- 原问题的解即为子问题的解的合并

**时间复杂度（主定理）**
$$
	T\left( n \right) =aT\left( \frac{n}{b} \right) +f\left( n \right)\\
	\Longrightarrow T\left( n \right) =\left\{ \begin{array}{l}
	\varTheta \left( n^{\log _ba} \right) \mspace{63mu}f\left( n \right) =O\left( n^{\log _ba-\varepsilon} \right) ,\varepsilon >0\\
	\varTheta \left( n^{\log _ba}\log n \right) \mspace{22mu}f\left( n \right) =\varTheta \left( n^{\log _ba} \right)\\
	\varTheta \left( f\left( n \right) \right) \mspace{70mu}f\left( n \right) =\varOmega \left( n^{\log _ba+\varepsilon} \right) ,\varepsilon >0\\
\end{array} \right.\\
$$

**一般步骤**

1. 将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题
2. 若子问题规模较小且易于解决时，则直接解
3. 若子问题规模较大且较难解决时，递归地分解，解决各子问题
4. 将各子问题的解合并为原问题的解

**可解问题的特征**

- 原问题能划分为几个形式相同的规模较小的子问题
- 子问题的解能合并为原问题的解
- 子问题之间相互独立

## $CDQ$分治

**使用条件**

- $CDQ$分治主要用于解决偏序问题
- 偏序集合指配备了部分排序关系的集合

**解决步骤**

1. 将原问题划分为两部分
2. 递归解决前半部分
3. 计算前半部分对后半部分的贡献
4. 递归解决后半部分
5. 合并前后两部分的答案

**算法本质**

- 是在进行序列重组（归并排序）时，比较全序关系是否满足
- 从而计算前面部分对后面部分的贡献

**对删除和变更操作的支持**

- “时光倒流”
  1. 进行一次分治后将时间倒过来
  2. 将删除操作变为原来的加入操作
- 时间线段树
  - $CDQ$分治整个过程就相当于建立了以时间为序的线段树
  - 其中的基本操作可以看做线段树上的操作
  - 因此可以建立以时间为序的线段树，用$Lazy$标记操作
  - 统计答案时，$DFS$或$BFS$线段树，输出叶子节点的答案即可

## 莫队算法

**使用要求**

- 原问题可转化为序列上离线的区间询问问题
- 若已知$\left[ L,R \right] $的答案，则可在$\varTheta \left( 1 \right) $内算出$\left[ L\pm 1,R \right] $或$\left[ L,R\pm 1 \right] $上的答案

**实现步骤**

1. 输入区间长度$N$，询问个数$M$和所有询问$\left[ L_i,R_i \right] $
2. 将所有询问按$L$分为长度为$\frac{N}{\sqrt{M}}$的多个块
3. 将所有操作按照$L$所在块的编号为第一关键字，$R$为第二关键字排序
4. 从左到右扫描，用上一个询问的答案更新现有询问的答案

**时间复杂度**

​		区间长度$N$，询问个数$M$时，时间复杂度为$\varTheta \left( N\sqrt{M} \right) $

**效率优化**

- 奇偶性优化
  - 在奇数号的块中$R$按升序排序，在偶数号的块中$R$按降序排序
  - 通过在块与块之间$R$更好地连接，使得时间复杂度中的常数更小
- 对修改操作的支持
  - 在原有的两维$L$和$R$上加入时间维$Time$
  
  - 当$N\approx M$时以$\sqrt{N}$为块大小，对$L$和$R$分块，继续用莫队算法
  
  - 时间复杂度$\varTheta \left( N^{\frac{5}{3}} \right) $
  

## 随机化算法

<font size=5>**随机数实现**</font>

- 线性同余法：$\begin{array}{c}
  	F_{N+1}=\left( A\cdot F_N+B \right) mod\,\,P\\
    	其中\,\,\left\{ \begin{array}{l}
    	gcd\left( B,P \right) =1\\
    	\forall \text{质数}K|P\gets  K|\left( A-1 \right)\\
    	4|P\gets  4|\left( A-1 \right)\\
    	A,B,F_0<P\\
    	A,B\in \mathbb{N}^{\ast}\\
  \end{array} \right.\\
  \end{array}$
  
- 平方取中法：$\begin{array}{c}
  	F_{N+1}=\lfloor \frac{F_{N}^{2}}{P^{\lfloor \frac{M}{2} \rfloor +1}} \rfloor mod\,\,P^M\\
    	其中\,\,\left\{ \begin{array}{l}
    	gcd\left( F_0,P^M \right) =1\\
    	F_0\in \left[ 1,P^M \right]\\
  \end{array} \right.\\
  \end{array}$
  
- $PRBS$算法：$F_{N+1}=P\left( F_N\ mod\ P^{M-1} \right) +f\left( F_N \right) \ mod\ P$

- `namespace std`算法
- `rand() in cstdlib`
   - `class mt19937 in random`
   - `random_shuffle(Fir,Sec[,Rand()]) in algorithm`
   - `shuffle(Fir,Sec,Rand()) in algorithm`

<font size=5>**模拟退火算法**</font>

- 模拟退火算法是一种随机化算法，以金属退火现象为模板
- 当问题的方案数极大（甚至无穷）且非单峰函数时，常用模拟退火求解

**实现步骤**

1. 将方案表示为$K$，能量（函数值）为$E$，温度为$T$，降温常数$A$
2. 初始化$K\gets K_0\quad E\gets F\left(K_0\right)\quad T\gets T_0$，其中$T_0$为一极大值
3. 每次随机选择猜测解$K'$，更新概率为$P\left( K\gets K' \right) =\left\{ \begin{array}{l}
   1\qquad F\left( K' \right) >F\left( K \right)\\
       	e^{\frac{F\left( K' \right) -F\left( K \right)}{T}}\quad else\\
   \end{array} \right. $
4. 在猜测和更新结束后，缩小$T$：$T\gets A\cdot T$
5. 循环步骤3~4，直到温度足够低或解足够精确为止

**注意事项**

- 初始温度$T_0$要极大，终止温度$T_1$要为一极小正实数
- 降温常数$A$为一个非常接近$1$但是小于$1$的数
- 一次模拟退火结束后要在当前最优解附近重新运行，尝试得到更优的解


<div STYLE="page-break-after: always;"></div>
# $OI$技巧

<font size=5>**读入／输出优化**</font>

**$C++$内部效率优化**

- 关闭与`stdio`同步：`std::ios::sync_with_stdio(false)`
- 关闭`std::cin`与`std::cout`的同步：`std::cin.tie(NULL)`

**与$C$的联动效率优化**

- 用`scanf()`和`printf()`代替`std::cin`和`std::cout`
- 用`getchar()`手动输入字符来优化输入
- 用`putchar()`手动递归输出字符来优化输出
- 将`putchar()`的递归式优化改为输出原数据的`char*`

**系统底层效率优化**

- 使用`std::fread(str,1,maxn,stdin)`读入所有字符，再内部处理
- 先内部处理，再使用`std::fwrite(str,1,maxn,stdout)`一起输出
- 在$Linux$系统中，可用`mmap()`代替`std::fread()`

<font size=5>**刷新缓存区的操作**</font>

- 结束程序`exit()`
- 关闭文件`fclose()`或`std::stream.close()`
- 用`printf()`将`\r`或`\n`输出到`stdout`
- 调用`fflush()`或`std::stream`调用`operator<<(flush)`
- 缓冲区满自动刷新
- 输出`std::endl`或`std::ends`

<font size=5>**常数优化**</font>

**代码层面的常数优化（一般都有用）**

- 输入输出优化：`getchar()`，`fread()`等（大数据时的主要优化）
- 手写`namespace std`的函数，以免模板展开耗费时间（常见优化）
- 用部分$C$语言库函数代替手打函数，优化速度（常见优化）：`isdigit(),stof(),atoi(),atol(),strtod(),strtol(),strtoul()`
- 进行取模优化，在取模时用`a+=b;a=(a>=p?a-p:a)`代替`a=(a+b)%p`
- 算法自身的常数优化（常见优化）

**编译器层面的常数优化（一般都有用）**

- 用`#define`和`inline`修饰较小函数，以减少过程调用（常见优化）
- 将循环展开，用小循环大操作量代替大循环小操作量（常见优化）
- 将简单操作写在一起，以提高$CPU$并行度，常与循环展开搭配使用
- 用加法代替乘法，位运算代替$2^k$的乘法

**硬件层面的常数优化（比较玄学）**

- 在循环遍历高维数组时，用指针链接枚举中间量以加速寻址
- 访问数据时使用有序访问而非随机访问，方便记录到缓存中（常见优化）
- 与输入数据无关的常数用`const`修饰，方便$CPU$存取（常见优化）
- 将循环变量用`register`修饰，以存储在$CPU$的寄存器中（常见优化）
- 将经常匹配`false`的`if`改为`?:`，减少分支预测错误的次数（常见优化）
- 在函数中用`var x`代替`var &x`，以消除不必要的内存引用
- 将同时调用的`a[i],b[i],c[i]`打包为`X{a,b,c}[i]`，提高空间局部性
- 避免使用步长为$2^k$的内存引用，避免高速缓存的低命中率

<div STYLE="page-break-after: always;"></div>
# 伪代码集锦

<font size=5>**$FFT,IFFT,NTT\ and\ INTT$**</font>

```c++
//*Data,*Mid should be numbered from 0
//Length=2^Integer
//Root(n,p) means (cos(2*Pi*p/n)+sin(2*Pi*p/n)*I)
void XTT(*Data,*Mid,int Length,bool is_IXTT){
    for(Pos=0;Pos<Length;++Pos)
        if(Pos<Rev(Pos))
            swap(Data[Pos],Data[Rev(Pos)]);
    for(Floor=1;(1<<Floor)<=Length;++Floor){
        for(Pos=0;Pos<Length;++Pos){
            if(Pos&(1<<Floor))
                Mid[Pos]=Data[Pos]
             	-(Data[Pos^(1<<Floor)]
                *Root(1<<Floor,
                      (Pos&((1<<Floor)-1)))
                  	  *(is_IXTT?-1:1));
            else
                Mid[Pos]=Data[Pos]
             	+(Data[Pos^(1<<Floor)]
                *Root(1<<Floor,
                      (Pos&((1<<Floor)-1)))
                  	  *(is_IXTT?-1:1));
        }
        for(Pos=0;Pos<Length;++Pos)
            Data[Pos]=Mid[Pos];
    }
    if(is_IXTT)
        for(Pos=0;Pos<Length;++Pos)
            Data[Pos]=Data[Pos]/Length;
}
```

<font size=5>**后缀自动机**</font>

```c++
//*String is numbered from 1
//The SAM is numbered from 0
void MakeSAM(*String,Length,*Len,**Move,*Fail){
    Last=0,Note=1,Len[0]=0,Fail[0]=-1;
    for(Pos=1;Pos<=Length;++Pos){
        Char=String[Pos];
        Len[Note]=Pos,Fail[Note]=-1;
        for(Pla=Last;;Pla=Fail[Pla]){
            if(Pla<0){
                Fail[Note]=0;
                Last=Note;
            	break;
            }
            if(!Move[Pla][Char])
                Move[Pla][Char]=Note;
            else{
                if(Len[Pla]==Len[Move[Pla][Char]]+1){
                    Fail[Note]=Move[Pla][Char];
                }
                else{
                    Clone=Note+1;
                    Move[Clone]=Move[Move[Pla][Char]];
                    Fail[Clone]=Fail[Move[Pla][Char]];
                    Len[Clone]=Len[Pla]+1;
                    Fail[Move[Pla][Char]]=Clone;
                    Fail[Note]=Clone;
                    Move[Pla][Char]=Clone;
                }
                Last=Note;
                break;
            }
        }
    }
}
```

<font size=5>**无旋$Treap$**</font>

**$Merge$函数**

```c++
Treap* Merge(Treap *Fir,Treap *Sec){
    if(!Fir||!Sec)
        return Fir&Sec;
    if(Fir->Data<Sec->Data){
        if(Fir->Key>Sec->Key){
            Fir->Right=Merge(Fir->Right,Sec);
            return Fir;
        }
        else{
            Sec->Left=Merge(Sec->Left,Fir);
            return Sec;
        }
    }
    else{
        if(Fir->Key>Sec->Key){
            Fir->Left=Merge(Fir->Left,Sec);
            return Fir;
        }
        else{
            Sec->Right=Merge(Sec->Right,Fir);
            return Sec;
        }
    }
}
```

**$Split$函数**

```c++
pair<Treap*,Treap*> Split(Treap *Heap,Type Comp){
    if(!Heap)
        return make_pair(NULL,NULL);
    if(Heap->Data<Comp){
        pair<Treap*,Treap*> Ans=Split(Heap->Right,Comp);
        Heap->Right=Ans.first;
        Ans.first=Heap;
        return Ans;
    }
    else{
        pair<Treap*,Treap*> Ans=Split(Heap->Left,Comp);
        Heap->Left=Ans.second;
        Ans.second=Heap;
        return Ans;
    }
}
```

<font size=5>**动态树**</font>

**$Splay$与$FleshLazy$函数**

```c++
void FleshLazy(Note *Ctrl){
    if(!Ctrl->Lazy)return;
    swap(Ctrl->Left,Ctrl->Right);
    if(Ctrl->Left)Ctrl->Left->Lazy^=true;
    if(Ctrl->Right)Ctrl->Right->Right^=true;
}
//Son() means which son of the note's father the note is
//if the note doesn't have father or isn't its father's son,Son() will return 0
//if the note is father's left son,Son() will return -1
//if the note is father's right son,Son() will return 1
//Rotate() will rotate the note and its father
void Splay(Note *Ctrl){
    while(Son(Ctrl)){
        if(Son(Ctrl->Father)){
            FleshLazy(Ctrl->Father->Father);
            FleshLazy(Ctrl->Father);
            if(Son(Ctrl->Father)!=Son(Ctrl))
                Rotate(Ctrl);
            else
                Rotate(Ctrl->Father);
        }
        else
            FleshLazy(Ctrl->Father);
        FleshLazy(Ctrl);
        Rotate(Ctrl);
    }
}
```

**访问$Access$**

```c++
void Access(Note *Ctrl){
    Splay(Ctrl);
    Ctrl->Right=NULL;
    while(Ctrl->Father){
        Ctrl->Father->Right=Ctrl;
        Splay(Ctrl);
    }
}
```

**换根$MakeRoot$**

```c++
void MakeRoot(Note *Ctrl){
    Access(Ctrl);
    Ctrl->Lazy^=true;
    FleshLazy(Ctrl);
}
```

**找根$FindRoot$**

```c++
Note* FindRoot(Note *Ctrl){
    Access(Ctrl);
    Note *Answer=Ctrl;
    while(Answer->Left)
        Answer=Answer->Left;
    return Answer;
}
```

**分离树链$Split$**

```c++
void Split(Note *Fir,Note *Sec){
    MakeRoot(Fir);
    Access(Sec);
}
```

**连接原树$Link$**

```c++
void Link(Note *Fir,Note *Sec){
    MakeRoot(Fir);
    Fir->Father=Sec;
}
```

**切断原树$Cut$**

```c++
bool Cut(Note *Fir,Note *Sec){
    Split(Fir,Sec);
    Splay(Fir);
    if(Fir->Right!=Sec||Sec->Left)
        return false;
    else{
        Fir->Right=NULL;
        Sec->Father=NULL;
        return true;
    }
}
```

